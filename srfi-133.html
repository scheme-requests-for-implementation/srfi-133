<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <!-- Non-indentation necessary for the commit check junk. -->
    <title>SRFI 133: Vector Library (R7RS-compatible)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <style type="text/css">
      /* <![CDATA[ */



      dt.ref:before {
        content: "[";
      }
      dt.ref:after {
        content: "]";
      }

      dt.proc-index {
        font-size: medium;
      }

      dt.type-spec {
        font-family: monospace;
        font-style: italic;
      }

      dt.proc-spec {
        font-family: monospace;
      }

      code.example-call {
      }
      code.example-value {
      }
      code.example-value:before {
        content: "=> "
      }
      /* ]]> */
    </style>
  </head>
  <body>

<H1>Title</H1>
Vector Library (R7RS-compatible)

<H1>Author</H1>
John Cowan (based on SRFI 43 by Taylor Campbell)

<h1>Issues</h1>

None at this time.

<h1 class="nonheader">Table of Contents</h1>
    <ul class="outer">
      <li>1. <a href="#Status">Status</a></li>
      <li>2. <a href="#Abstract">Abstract</a></li>
      <li>3. <a href="#Rationale">Rationale</a></li>
      <li>4. <a href="#ProcIndex">Procedure Index</a></li>
      <li>
        5. <a href="#Procs">Procedures</a>
        <ul>
          <li>5.1. <a href="#Constructors">Constructors</a></li>
          <li>5.2. <a href="#Predicates">Predicates</a></li>
          <li>5.3. <a href="#Selectors">Selectors</a></li>
          <li>5.4. <a href="#Iteration">Iteration</a></li>
          <li>5.5. <a href="#Searching">Searching</a></li>
          <li>5.6. <a href="#Mutators">Mutators</a></li>
          <li>5.7. <a href="#Conversion">Conversion</a></li>
        </ul>
      </li>
      <li>6. <a href="#SampImpl">Sample Implementation</a></li>
      <li>7. <a href="#Acknowledgements">Acknowledgements</a></li>
      <li>8. <a href="#References">References</a></li>
      <li>9. <a href="#Copyright">Copyright</a></li>
    </ul>

    <h1 class="nonheader"><a name="Status">1. Status</a></h1>

    <p>This SRFI is currently in <em>final</em> status. Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+133+at+srfi+dotschemers+dot+org">srfi-133@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="http://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-133">archive</a>.</p>
    <ul>
      <li>Received: 2015-12-15</li>
      <li>60-day deadline: 2016-02-14</li>
      <li>Draft #1 published: 2015-12-16</li>
      <li>Draft #2 published: 2016-01-24</li>
      <li>Draft #3 published: 2016-01-31</li>
      <li>Draft #4 published: 2016-03-12</li>
      <li>Finalized: 2016-03-20</li>
      <li>Revised to fix errata:
      <ul>
	<li>2016-04-01 (Fixed description of <code>vector-unfold!</code>)</li>
	<li>2016-08-10 (Fixed typos.)</li>
	<li>2016-09-02 (Changed order of arguments to <code>vector-cumulate</code>
	  from <code>(vector-cumulate f vec knil)</code> to
          <code>(vector-cumulate f knil vec)</code> to match the
          argument order of <tt>vector-fold</tt>.)</li>
	<li>2017-06-05 (Added second return type of <code>vector-partition</code>.)</li>
	<li>2018-07-04 (Removed requirement that <code>elt=?</code>
	  argument be consistent with <code>eq?</code>.)</li>
	<li>2018-10-27 (Fixed typos.)</li></ul></ul>

    <p><b>Post-finalization note</b>: The finalized version of this
      SRFI required the equality operator used by the
      <code>vector=</code> procedure to be consistent with
      <code>eq?</code>.  However, <code>=</code> is not consistent
      with <code>eq?</code> in a Scheme which provides NaN values and
      IEEE semantics for them, as <code>(eq? +nan.0 +nan.0)</code> may
      return either <code>#t</code> or <code>#f</code> but <code>(=
      +nan.0 +nan.0)</code> must return <code>#f. </code> This means
      that the expected semantics of <code>=</code> when used with
      <code>vector=</code> are violated.  Therefore, the requirement
      for consistency has been removed from this version, and the
      sample implementation adjusted accordingly.</p>

    <h1 class="nonheader"><a name="Abstract">2. Abstract</a></h1>
    <p>
      This <a href="#SRFI">SRFI</a> proposes a comprehensive
      library of vector operations accompanied by a freely
      available and complete reference implementation.  The reference
      implementation is unencumbered by copyright, and useable with no
      modifications on any Scheme system that is
      <a href="#R5RS">R5RS</a>-compliant.  It also provides several
      hooks for implementation-specific optimization as well.
    </p>


    <h1 class="nonheader"><a name="Rationale">3. Rationale</a></h1>
    <p>
      <a href="#R5RS">R5RS</a> provides very few list-processing
      procedures, for which reason <a href="#SRFI-1">SRFI 1</a> exists.  However,
      <a href="#R5RS">R5RS</a> provides even fewer vector operations
      &mdash; while it provides mapping, appending, et cetera
      operations for lists, it specifies only nine vector manipulation
      operations:
    </p>

    <ul class="indented">
      <li><tt><a href="#vector-p">vector?</a></tt></li>
      <li><tt><a href="#make-vector">make-vector</a></tt></li>
      <li><tt><a href="#vector">vector</a></tt></li>
      <li><tt><a href="#vector-length">vector-length</a></tt></li>
      <li><tt><a href="#vector-ref">vector-ref</a></tt></li>
      <li><tt><a href="#vector-set-bang">vector-set!</a></tt></li>
      <li><tt><a href="#vector-to-list">vector-&gt;list</a></tt></li>
      <li><tt><a href="#list-to-vector">list-&gt;vector</a></tt></li>
      <li><tt><a href="#vector-fill-bang">vector-fill!</a></tt></li>
    </ul>
    <p>
      <a href="#R7RS-small">R7RS-small</a> added support for
      <i>start</i> and <i>end</i> arguments to <code>vector->list</code>,
      <code>list->vector</code> and <code>vector-fill!</code>.  It also
      provided seven additional vector procedures,  bringing vectors
      and lists to approximate parity:
    </p>

    <ul class="indented">
      <li><tt><a href="#vector-copy">vector-copy</a></tt></li>
      <li><tt><a href="#vector-copy-bang">vector-copy!</a></tt></li>
      <li><tt><a href="#vector-append">vector-append</a></tt></li>
      <li><tt><a href="#vector-map">vector-map</a></tt></li>
      <li><tt><a href="#vector-for-each">vector-for-each</a></tt></li>
      <li><tt><a href="#vector-to-string">vector-&gt;string</a></tt></li>
      <li><tt><a href="#string-to-vector">string-&gt;vector</a></tt></li>
    </ul>

    <p>
     <a href="#SRFI-43">SRFI 43</a> standardized more vector procedures,
     all of which are included in this SRFI.  Unfortunately, R7RS-small
     and SRFI 43 placed irreconcileable requirements on the procedures
     invoked by <tt>vector-map</tt> and <tt>vector-for-each</tt>.
     This SRFI resolves that issue by changing these SRFI 43
     procedures as well as <tt>vector-map!</tt>, <tt>vector-fold</tt>,
     <tt>vector-fold-right</tt>, and <tt>vector-count</tt> to leave
     out the <var>index</var> argument that is passed under SRFI 43's
     definition.</p>
     <p>In addition, the version of <code>vector-copy</code> in this SRFI
     does not require support for a <var>fill</var> argument, which
     makes it equivalent to the R7RS-small definition.</p>

     <p>This SRFI also provides the following new procedures (some from
     Python, some from other sources):
    </p>

    <ul class="indented">
      <li><tt><a href="#vector-unfold-bang">vector-unfold!</a></tt></li>
      <li><tt><a href="#vector-unfold-right-bang">vector-unfold-right!</a></tt></li>
      <li><tt><a href="#vector-append-subvectors">vector-append-subvectors</a></tt></li>
      <li><tt><a href="#vector-cumulate">vector-cumulate</a></tt></li>
      <li><tt><a href="#vector-partition">vector-partition</a></tt></li>
    </ul>



    <p>
      It should be noted that no vector sorting procedures are provided
      by this SRFI, because there already are several SRFIs for that purpose.
    </p>

    <h1 class="nonheader">
      <a name="ProcIndex">4. Procedure Index</a>
    </h1>
    <p>
      Here is an index of the procedures provided by this package.
      Those marked by <i>italics</i> are also provided in
      <a href="#R7RS-small">R7RS-small</a>.
    </p>
    <dl>
      <dt class="proc-index">
        &middot;&nbsp;<a href="#Constructors">Constructors</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <i><a href="#make-vector">make-vector</a></i>
          <i><a href="#vector">vector</a></i>
          <br />
          <a href="#vector-unfold">vector-unfold</a>
          <a href="#vector-unfold-right">vector-unfold-right</a>
          <br />
          <i><a href="#vector-copy">vector-copy</a></i>
          <a href="#vector-reverse-copy">vector-reverse-copy</a>
          <br />
          <i><a href="#vector-append">vector-append</a></i>
          <a href="#vector-concatenate">vector-concatenate</a>
          <a href="#vector-append-subvectors">vector-append-subvectors</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Predicates">Predicates</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <i><a href="#vector-p">vector?</a></i>
          <br />
          <a href="#vector-empty-p">vector-empty?</a>
          <br />
          <a href="#vector-eq">vector=</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Selectors">Selectors</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <i><a href="#vector-ref">vector-ref</a></i>
          <br />
          <i><a href="#vector-length">vector-length</a></i>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Iteration">Iteration</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <a href="#vector-fold">vector-fold</a>
          <a href="#vector-fold-right">vector-fold-right</a>
          <br />
          <i><a href="#vector-map">vector-map</a></i>
          <a href="#vector-map-bang">vector-map!</a>
          <br />
          <i><a href="#vector-for-each">vector-for-each</a></i>
          <a href="#vector-count">vector-count</a>
          <br />
          <a href="#vector-cumulate">vector-cumulate</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Searching">Searching</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <a href="#vector-index">vector-index</a>
          <a href="#vector-index-right">vector-index-right</a>
          <br />
          <a href="#vector-skip">vector-skip</a>
          <a href="#vector-skip-right">vector-skip-right</a>
          <br />
          <a href="#vector-binary-search">vector-binary-search</a>
          <br />
          <a href="#vector-any">vector-any</a>
          <a href="#vector-every">vector-every</a>
          <br />
          <a href="#vector-partition">vector-partition</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Mutators">Mutators</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <a href="#vector-set-bang">vector-set!</a>
          <a href="#vector-swap-bang">vector-swap!</a>
          <br />
          <a href="#vector-fill-bang">vector-fill!</a>
          <a href="#vector-reverse-bang">vector-reverse!</a>
          <br />
          <a href="#vector-copy-bang">vector-copy!</a>
          <a href="#vector-reverse-copy-bang">vector-reverse-copy!</a>
          <br />
          <a href="#vector-unfold-bang">vector-unfold!</a>
          <a href="#vector-unfold-right-bang">vector-unfold-right!</a>
          <br />
          <br />
        </code>
      </dd>

      <dt class="proc-index">
        &middot;&nbsp;<a href="#Conversion">Conversion</a>
        <br />
        <br />
      </dt>
      <dd>
        <code>
          <i><a href="#vector-to-list">vector-&gt;list</a></i>
          <a href="#reverse-vector-to-list">reverse-vector-&gt;list</a>
          <br />
          <i><a href="#list-to-vector">list-&gt;vector</a></i>
          <a href="#reverse-list-to-vector">reverse-list-&gt;vector</a>
          <br />
          <i><a href="#vector-to-string">vector-&gt;string</a></i>
          <i><a href="#string-to-vector">string-&gt;vector</a></i>
        </code>
      </dd>
    </dl>

    <h1 class="nonheader"><a name="Procs">5. Procedures</a></h1>
    <p>
      In this section containing specifications of procedures, the
      following notation is used to specify parameters and return
      values:
    </p>
    <dl class="indented">
      <dt class="type-spec">
        (f arg<sub>1</sub> arg<sub>2</sub> ...)
        -&gt; something</dt>
      <dd>
        Indicates a function <tt><i>f</i></tt> takes the parameters
        <tt><i>arg<sub>1</sub> arg<sub>2</sub>
        ...</i></tt> and returns a value of the
        type <tt><i>something</i></tt>.  If <tt><i>something</i></tt>
        is <tt>unspecified</tt>, then <tt><i>f</i></tt> returns a single
        implementation-dependent value; this SRFI does not specify what it
        returns, and in order to write portable code, the return value
        should be ignored.
        <br />
        <br />
      </dd>

      <dt class="type-spec">vec</dt>
      <dd>
        The argument in this place must be a vector, i.e. it must
        satisfy the predicate
        <tt><a href="#vector-p">vector?</a></tt>.
        <br />
        <br />
      </dd>

      <dt class="type-spec">i, j, start, size</dt>
      <dd>
        The argument in this place must be a exact nonnegative integer, i.e.
        it must satisfy the predicates <tt>exact?</tt>, <tt>integer?</tt> and either
        <tt>zero?</tt> or <tt>positive?</tt>.  The third case of it
        indicates the index at which traversal begins; the fourth case
        of it indicates the size of a vector.
        <br />
        <br />
      </dd>

      <dt class="type-spec">end</dt>
      <dd>
        The argument in this place must be a exact positive integer, i.e. it
        must satisfy the predicates <tt>exact?</tt>, <tt>integer?</tt> and
        <tt>positive?</tt>.  This indicates the index directly before
        which traversal will stop &mdash; processing will occur until
        the the index of the vector is <tt><i>end</i></tt>.  It is the
        closed right side of a range.
        <br />
        <br />
      </dd>

      <dt class="type-spec">f</dt>
      <dd>
        The argument in this place must be a function of one or more
        arguments, which returns (except as noted otherwise) exactly one value.
        <br />
        <br />
      </dd>

      <dt class="type-spec">pred?</dt>
      <dd>
        The argument in this place must be a function of one or more
        arguments that returns one value, which is treated as a
        boolean.
        <br />
        <br />
      </dd>

      <dt class="type-spec">
        x, y, z, seed, knil, fill, key, value
      </dt>
      <dd>
        The argument in this place may be any Scheme value.
        <br />
        <br />
      </dd>

      <dt class="type-spec">[something]</dt>
      <dd>
        Indicates that <tt><i>something</i></tt> is an optional
        argument; it needn't necessarily be applied.
        <tt><i>Something</i></tt> needn't necessarily be one thing; for
        example, this usage of it is perfectly valid:
        <br />
        <br />
        <code>
          &nbsp;&nbsp;&nbsp;[start [end]]
        </code>
        <br />
        <br />
        and is indeed used quite often.
        <br />
        <br />
      </dd>

      <dt class="type-spec">something ...</dt>
      <dd>
        Indicates that zero or more <tt><i>something</i></tt>s are
        allowed to be arguments.
        <br />
        <br />
      </dd>

      <dt class="type-spec">
        something<sub>1</sub> something<sub>2</sub>
        ...
      </dt>
      <dd>
        Indicates that at least one <tt><i>something</i></tt> must be
        arguments.
        <br />
        <br />
      </dd>

      <dt class="type-spec">
        something<sub>1</sub> something<sub>2</sub>
        ...
        something<sub>n</sub>
      </dt>
      <dd>
        Exactly equivalent to the previous argument notation, but this
        also indicates that <tt><i>n</i></tt> will be used later in the
        procedure description.
        <br />
        <br />
      </dd>
    </dl>

    <p>
      It should be noted that all of the procedures that iterate across
      multiple vectors in parallel stop iterating and produce the final
      result when the end of the shortest vector is reached.  The sole
      exception is <tt><a href="#vector-eq">vector=</a></tt>, which
      automatically returns <tt>#f</tt> if the vectors' lengths vary.
    </p>

    <h2><a name="Constructors">5.1. Constructors</a></h2>
    <dl>
      <dt class="proc-spec">
        <a name="make-vector">
          (make-vector <i>size</i> [<i>fill</i>])
          -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Creates and returns a vector
        of size <tt><i>size</i></tt>.
        If <i>fill</i> is specified, all the elements of the vector
        are initialized to <i>fill</i>.  Otherwise, their contents
        are indeterminate.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (make-vector 5 3)
        </code>
        <br />
        <code class="example-value">
          #(3 3 3 3 3)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector">
          (vector <i>x ...</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Creates and returns a vector
        whose elements are <tt><i>x ...</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector 0 1 2 3 4)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 3 4)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-unfold">
          (vector-unfold <i>f length initial-seed
                            ...</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        The fundamental vector constructor.  Creates a vector whose
        length is <tt><i>length</i></tt> and iterates across each index
        <tt><i>k</i></tt> between <tt>0</tt> and
        <tt><i>length</i></tt>, applying <tt><i>f</i></tt> at each
        iteration to the current index and current seeds, in that
        order, to receive <tt><i>n</i> + 1</tt> values: first, the
        element to put in the <tt><i>k</i></tt>th slot of the new
        vector and <tt><i>n</i></tt> new seeds for the next iteration.
        It is an error for the number of seeds to vary between
        iterations.  Note that the termination condition is different from
        the <code>unfold</code> procedure of <a href="#SRFI-1">SRFI 1</a>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-unfold (&lambda; (i x) (values x (- x 1)))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         10 0)
        </code>
        <br />
        <code class="example-value">
          #(0 -1 -2 -3 -4 -5 -6 -7 -8 -9)
        </code>
        <br />
        <br />
        Construct a vector of the sequence of integers in the range
        [0,<tt><i>n</i></tt>).
        <br />
        <code class="example-call">
          (vector-unfold values <tt><i>n</i></tt>)
        </code>
        <br />
        <code class="example-value">
          #(0 1 2 ... <i>n-2</i> <i>n-1</i>)
        </code>
        <br />
        <br />
        Copy <tt><i>vector</i></tt>.
        <br />
        <br />
        <code class="example-call">
          (vector-unfold (&lambda; (i) (vector-ref <i>vector</i> i))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         (vector-length <i>vector</i>))
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-unfold-right">
          (vector-unfold-right <i>f length initial-seed
                                  ...</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-unfold">vector-unfold</a></tt>, but
        it uses <tt><i>f</i></tt> to generate elements from
        right-to-left, rather than left-to-right.
        The first index used is <i>length</i> - 1.
        Note that the termination condition is different from
        the <code>unfold-right</code> procedure of <a href="#SRFI-1">SRFI 1</a>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        Construct a vector of pairs of non-negative integers whose
        values sum to 4.
        <br />
        <br />
        <code class="example-call">
          (vector-unfold-right (&lambda; (i x) (values (cons i x) (+ x 1))) 5 0)
        </code>
        <br />
        <code class="example-value">
          #((0 . 4) (1 . 3) (2 . 2) (3 . 1) (4 . 0))
        </code>
        <br />
        <br />
        Reverse <tt><i>vector</i></tt>.
        <br />
        <br />
        <code class="example-call">
          (vector-unfold-right (&lambda; (i x)
                                 (values (vector-ref <i>vector</i> x)
                                         (+ x 1)))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                               (vector-length <i>vector</i>)
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                               0)
        </code>
        <br />
        <br />
      </dd>

<!-- VECTOR-TABULATE has been flushed in favour of VECTOR-UNFOLD.
      <dt class="proc-spec">
        <a name="vector-tabulate">
          (vector-tabulate <i>f size</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        Creates a new vector whose size is <tt><i>size</i></tt> and
        fills it by applying <tt><i>f</i></tt> to each index in the
        vector, in an unspecified order.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-tabulate - 5)
        </code>
        <br />
        <code class="example-value">
          #(0 -1 -2 -3 -4)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-tabulate (&lambda; (x) (* x x)) 5)
        </code>
        <br />
        <code class="example-value">
          #(0 1 4 9 16)
        </code>
        <br />
        <br />
      </dd>
-->

      <dt class="proc-spec">
        <a name="vector-copy">
          (vector-copy <i>vec</i>
                       [<i>start</i> [<i>end</i>]])
          -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>]
        Allocates a new vector whose length is <tt><i>end</i> -
        <i>start</i></tt> and fills it with elements from
        <tt><i>vec</i></tt>, taking elements from <tt><i>vec</i></tt>
        starting at index <tt><i>start</i></tt> and stopping at index
        <tt><i>end</i></tt>.  <tt><i>Start</i></tt> defaults to
        <tt>0</tt> and <tt><i>end</i></tt> defaults to the value of
        <tt>(<a href="#vector-length">vector-length</a>
        <i>vec</i>)</tt>.
        SRFI 43 provides an optional <var>fill</var> argument to supply
        values if <var>end</var> is greater than the length of <var>vec</var>.
        Neither R7RS-small nor this SRFI requires support for this argument.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-copy '#(a b c d e f g h i))
        </code>
        <br />
        <code class="example-value">
          #(a b c d e f g h i)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-copy '#(a b c d e f g h i) 6)
        </code>
        <br />
        <code class="example-value">
          #(g h i)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-copy '#(a b c d e f g h i) 3 6)
        </code>
        <br />
        <code class="example-value">
          #(d e f)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-reverse-copy">
          (vector-reverse-copy <i>vec</i>
                               [<i>start</i> [<i>end</i>]])
          -&gt; vector
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-copy">vector-copy</a></tt>, but it
        copies the elements in the reverse order from
        <tt><i>vec</i></tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-reverse-copy '#(5 4 3 2 1 0) 1 5)
        </code>
        <br />
        <code class="example-value">
          #(1 2 3 4)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-append">
          (vector-append <i>vec ...</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>]
        Returns a newly allocated vector that contains all elements in
        order from the subsequent locations in <tt><i>vec
        ...</i></tt>.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-append '#(x) '#(y))
        </code>
        <br />
        <code class="example-value">
          #(x y)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-append '#(a) '#(b c d))
        </code>
        <br />
        <code class="example-value">
          #(a b c d)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-append '#(a #(b)) '#(#(c)))
        </code>
        <br />
        <code class="example-value">
          #(a #(b) #(c))
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-concatenate">
          (vector-concatenate <i>list-of-vectors</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        Appends each vector in <tt><i>list-of-vectors</i></tt>.  This
        is equivalent to:
        <br />
        <br />
        <code class="indented">
          (apply <a href="#vector-append">vector-append</a>
                 <i>list-of-vectors</i>)
        </code>
        <br />
        <br />
        However, it may be implemented better.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-concatenate '(#(a b) #(c d)))
        </code>
        <br />
        <code class="example-value">
          #(a b c d)
        </code>
        <br />
        <br />
      </dd>
      <dt class="proc-spec">
        <a name="vector-append-subvectors">
          (vector-append-subvectors [<i>vec start end] ...</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        Returns a vector that contains every element of each <i>vec</i>
        from <i>start</i> to <i>end</i> in the specified order.
        This procedure is a generalization of <tt>vector-append</tt>.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-append-subvectors '#(a b c d e) 0 2 '#(f g h i j) 2 4)
        </code>
        <br />
        <code class="example-value">
          #(a b h i)
        </code>
        <br />
        <br />
      </dd>
    </dl>


    <h2><a name="Predicates">5.2. Predicates</a></h2>
    <dl>
      <dt class="proc-spec">
        <a name="vector-p">
          (vector? <i>x</i>)
          -&gt; boolean
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Disjoint type predicate for
        vectors: this returns <tt>#t</tt> if <tt><i>x</i></tt> is a
        vector, and <tt>#f</tt> if otherwise.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector? '#(a b c))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? '(a b c))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? #t)
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? '#())
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector? '())
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-empty-p">
          (vector-empty? <i>vec</i>)
          -&gt; boolean
        </a>
      </dt>
      <dd>
        Returns <tt>#t</tt> if <tt><i>vec</i></tt> is empty, i.e. its
        length is <tt>0</tt>, and <tt>#f</tt> if not.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#(a))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#(()))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#(#()))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-empty? '#())
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-eq">
          (vector= <i>elt=? vec ...</i>)
          -&gt; boolean
        </a>
      </dt>
      <dd>
        Vector structure comparator, generalized across user-specified
        element comparators.  Vectors <tt><i>a</i></tt> and
        <tt><i>b</i></tt> are considered equal by <tt>vector=</tt> if
        their lengths are the same, and for each respective element
        <tt><i>E</i><sub>a</sub></tt> and
        <tt><i>E</i><sub>b</sub></tt>, <tt>(<i>elt=? E</i><sub>a</sub>
        <i>E</i><sub>b</sub>)</tt> returns a true value.
        <tt><i>Elt=?</i></tt> is always applied to two arguments.
        <br />
        <br />
        If there are only zero or one vector arguments, <tt>#t</tt> is
        automatically returned.  The dynamic order in which comparisons
        of elements and of vectors are performed is left completely
        unspecified; do not rely on a particular order.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector= eq? '#(a b c d) '#(a b c d))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= eq? '#(a b c d) '#(a b d c))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= = '#(1 2 3 4 5) '#(1 2 3 4))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= = '#(1 2 3 4) '#(1 2 3 4))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        The two trivial cases.
        <br />
        <br />
        <code class="example-call">
          (vector= eq?)
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= eq? '#(a))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
        Note the fact that we don't use vector literals in the next two
        &mdash; it is unspecified whether or not literal vectors with
        the same external representation are <tt>eq?</tt>.
        <br />
        <br />
        <code class="example-call">
          (vector= eq? (vector (vector 'a)) (vector (vector 'a)))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector= equal? (vector (vector 'a)) (vector (vector 'a)))
        </code>
        <br />
        <code class="example-value">
          #t
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h2><a name="Selectors">5.3. Selectors</a></h2>
    <dl>
      <dt class="proc-spec">
        <a name="vector-ref">
          (vector-ref <i>vec i</i>)
          -&gt; value
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Vector element dereferencing:
        returns the value that the location in <tt><i>vec</i></tt> at
        <tt><i>i</i></tt> is mapped to in the store.  Indexing is based
        on zero.  <tt><i>I</i></tt> must be within the range [0,
        <tt>(<a href="#vector-length">vector-length</a>
             <i>vec</i>)</tt>).
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-ref '#(a b c d) 2)
        </code>
        <br />
        <code class="example-value">
          c
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-length">
          (vector-length <i>vec</i>)
          -&gt; exact nonnegative integer
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Returns the length of <tt><i>vec</i></tt>, the number of
        locations reachable from <tt><i>vec</i></tt>.  (The careful
        word 'reachable' is used to allow for 'vector slices,' whereby
        <tt><i>vec</i></tt> refers to a larger vector that contains
        more locations that are unreachable from <tt><i>vec</i></tt>.
        This SRFI does not define vector slices, but later SRFIs may.)
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-length '#(a b c))
        </code>
        <br />
        <code class="example-value">
          3
        </code>
        <br />
        <br />
      </dd>
    </dl>

    <h2><a name="Iteration">5.4. Iteration</a></h2>
    <dl>
      <dt class="proc-spec">
        <a name="vector-fold">
          (vector-fold <i>kons knil vec<sub>1</sub> vec<sub>2</sub>
                          ...</i>)
          -&gt; value
        </a>
      </dt>
      <dd>
        The fundamental vector iterator.  <tt><i>Kons</i></tt> is
        iterated over each value in all of the vectors, stopping at the
        end of the shortest; <tt><i>kons</i></tt> is applied as
        <tt>
          (<i>kons</i> <i>state</i>
            (<a href="#vector-ref">vector-ref</a>
             <i>vec<sub>1</sub></i> <i>i</i>)
            (<a href="#vector-ref">vector-ref</a>
             <i>vec<sub>2</sub></i> <i>i</i>)
            ...)
        </tt>
        where <tt><i>state</i></tt> is the current state value &mdash;
        the current state value begins with <tt><i>knil</i></tt>, and
        becomes whatever <tt><i>kons</i></tt> returned on the
        previous iteration &mdash;, and <tt><i>i</i></tt> is the
        current index.
        <br />
        <br />
        The iteration is strictly left-to-right.
        <br />
        <br />
        Examples:
        <br />
        <br />
        Find the longest string's length in
        <tt><i>vector-of-strings</i></tt>.
        <br />
        <code class="example-call">
          (vector-fold (&lambda; (len str)
                         (max (string-length str) len))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;
                       0 <i>vector-of-strings</i>)
        </code>
        <br />
        <br />
        Produce a list of the reversed elements of
        <tt><i>vec</i></tt>.
        <br />
        <code class="example-call">
          (vector-fold (&lambda; (tail elt) (cons elt tail))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;
                       '() <i>vec</i>)
        </code>
        <br />
        <br />
        Count the number of even numbers in <tt><i>vec</i></tt>.
        <br />
        <code class="example-call">
          (vector-fold (&lambda; (counter n)
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         (if (even? n) (+ counter 1) counter))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;
                       0 <i>vec</i>)
        </code>
        <br />
        <br />
      </dd>
      <dt class="proc-spec">
        <a name="vector-fold-right">
          (vector-fold-right <i>kons knil
                                vec<sub>1</sub> vec<sub>2</sub>
                                ...</i>)
          -&gt; value
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-fold">vector-fold</a></tt>, but
        it iterates right to left instead of left to right.
        <br />
        <br />
        Example:
        <br />
        <br />
        Convert a vector to a list.
        <br />
        <code class="example-call">
          (vector-fold-right (&lambda; (tail elt)
                               (cons elt tail))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                             '() '#(a b c d))
        </code>
        <br />
        <code class="example-value">
          (a b c d)
        </code>
        <br />
        <br />
      </dd>
    </dl>
    <dl>
      <dt class="proc-spec">
        <a name="vector-map">
          (vector-map <i>f vec<sub>1</sub> vec<sub>2</sub>
                         ...</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>]
        Constructs a new vector of the shortest size of the vector
        arguments.  Each element at index <tt><i>i</i></tt> of the new
        vector is mapped from the old vectors by
        <tt>(<i>f</i> (<a href="#vector-ref">vector-ref</a>
              <i>vec<sub>1</sub></i>
              <i>i</i>)
             (<a href="#vector-ref">vector-ref</a>
              <i>vec<sub>2</sub></i>
              <i>i</i>)
             ...)</tt>.
        The dynamic order of application of <tt><i>f</i></tt> is
        unspecified.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-map (&lambda; (x) (* x x))
          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;
                      (<a href="#vector-unfold">vector-unfold</a>
                       (&lambda; (i x) (values x (+ x 1)))
                       4 1))
        </code>
        <br />
        <code class="example-value">
          #(1 4 9 16)
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-map (&lambda; (x y) (* x y))<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;(<a href="#vector-unfold">vector-unfold</a>
                             (&lambda; (x) (values x (+ x 1)))
                             5 1)<br />
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;(<a href="#vector-unfold">vector-unfold</a>
                             (&lambda; (x) (values x (- x 1)))
                             5 5))
        </code>
        <br />
        <code class="example-value">
          #(5 8 9 8 5)
        </code>
        <br />
        <br />
        <code class="example-call">
          (let ((count 0))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;
          (vector-map (&lambda; (ignored-elt)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (set! count (+ count 1))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          count)
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;
          '#(a b)))
        </code>
        <br />
        <code class="example-value">
          #(1 2) <i>OR</i> #(2 1)
        </code>
        <br />
        <br />
      </dd>
    </dl>
    <dl>
      <dt class="proc-spec">
        <a name="vector-map-bang">
          (vector-map! <i>f vec<sub>1</sub> vec<sub>2</sub>
                          ...</i>)
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        Similar to <tt><a href="#vector-map">vector-map</a></tt>, but
        rather than mapping the new elements into a new vector, the new
        mapped elements are destructively inserted into
        <tt><i>vec<sub>1</sub></i></tt>.  Again, the dynamic order of
        application of <tt><i>f</i></tt> unspecified, so it is
        dangerous for <tt><i>f</i></tt> to apply either
        <tt><a href="#vector-ref">vector-ref</a></tt> or
        <tt><a href="#vector-set-bang">vector-set!</a></tt> to
        <tt><i>vec<sub>1</sub></i></tt> in <tt><i>f</i></tt>.
        <br />
      </dd>
    </dl>
    <dl>
      <dt class="proc-spec">
        <a name="vector-for-each">
          (vector-for-each <i>f vec<sub>1</sub> vec<sub>2</sub>
                              ...</i>)
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>]
        Simple vector iterator: applies <tt><i>f</i></tt> to
        the corresponding list of parallel elements
        from <tt><i>vec<sub>1</sub> vec<sub>2</sub></i>
        ...</tt>
        in the range [0, <tt><i>length</i></tt>), where
        <tt><i>length</i></tt> is the length of the smallest vector
        argument passed,
        In contrast with
        <tt><a href="#vector-map">vector-map</a></tt>, <tt><i>f</i></tt>
        is reliably applied to each subsequent element, starting at
        index 0, in the vectors.
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-for-each (&lambda; (x) (display x) (newline))
        </code>
        <br />
        <code class="example-call">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          '#("foo" "bar" "baz" "quux" "zot"))
        </code>
        <br />
        Displays:
        <br />
        <pre>
foo
bar
baz
quux
zot</pre>
      </dd>
    </dl>
    <dl>
      <dt class="proc-spec">
        <a name="vector-count">
          (vector-count <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                           ...</i>)
          -&gt; exact nonnegative integer
        </a>
      </dt>
      <dd>
        Counts the number of parallel elements in the vectors that
        satisfy <tt><i>pred?</i></tt>, which is applied, for each index
        <tt><i>i</i></tt> in the range [0, <tt><i>length</i></tt>)
        where <tt><i>length</i></tt> is the length of the
        smallest vector argument, to each
        parallel element in the vectors, in order.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-count even?
                        '#(3 1 4 1 5 9 2 5 6))
        </code>
        <br />
        <code class="example-value">
          3
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-count &lt;
                        '#(1 3 6 9) '#(2 4 6 8 10 12))
        </code>
        <br />
        <code class="example-value">
          2
        </code>
        <br />
        <br />
      </dd>
    </dl>
    <dl>
      <dt class="proc-spec">
        <a name="vector-cumulate">
          (vector-cumulate <i>f knil vec</i>)
          -&gt; vector
        </a>
      </dt>
      <dd>
        Returns a newly allocated vector <tt><i>new</i></tt>
        with the same length as <tt><i>vec</i></tt>.
        Each element <i>i</i> of <i>new</i> is set to the result of invoking
        <tt><i>f</i></tt> on <i><tt>new</tt><sub>i-1</sub></i>
        and <i><tt>vec</tt><sub>i</sub></i>,
        except that for the first call on <i>f</i>, the first argument is
        <i>knil</i>.  The <i>new</i> vector is returned.
	<p>Note that the order of arguments to <code>vector-cumulate</code> was changed by <code>errata-3</code> on 2016-09-02.</p>
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-cumulate + 0 '#(3 1 4 1 5 9 2 5 6))
        </code>
        <br />
        <code class="example-value">
          #(3 4 8 9 14 23 25 30 36)
        </code>
        <br />
        <br />
        <br />
        <br />
      </dd>
    </dl>

    <h2><a name="Searching">5.5. Searching</a></h2>
    <dl>
      <dt class="proc-spec">
        <a name="vector-index">
          (vector-index <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                           ...</i>)
          -&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Finds &amp; returns the index of the first elements in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        ...</i></tt> that satisfy
        <tt><i>pred?</i></tt>.  If no matching element is found by the
        end of the shortest vector, <tt>#f</tt> is returned.
        <br />
        <br />
        Examples:
        <br />
        <br />
        <code class="example-call">
          (vector-index even? '#(3 1 4 1 5 9))
        </code>
        <br />
        <code class="example-value">
          2
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-index &lt; '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
        </code>
        <br />
        <code class="example-value">
          1
        </code>
        <br />
        <br />
        <code class="example-call">
          (vector-index = '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
        </code>
        <br />
        <code class="example-value">
          #f
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-index-right">
          (vector-index-right <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                                 ...</i>)
          -&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-index">vector-index</a></tt>, but it
        searches right-to-left, rather than left-to-right, and all of
        the vectors <i>must</i> have the same length.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-skip">
          (vector-skip <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                          ...</i>)
          -&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Finds &amp; returns the index of the first elements in
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        ...</i></tt> that do <i>not</i> satisfy
        <tt><i>pred?</i></tt>.  If all the values in the vectors
        satisfy <tt><i>pred?</i></tt> until the end of the shortest
        vector, this returns <tt>#f</tt>. This is equivalent to:
        <br />
        <br />
        <code class="indented">
          (<a href="#vector-index">vector-index</a>
           (&lambda; (x<sub><i>1</i></sub> x<sub><i>2</i></sub>
                      <i> ...</i>)
             (not (<i>pred?</i> x<sub><i>1</i></sub>
                                x<sub><i>1</i></sub>
                                <i> ...</i>)))
           <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           <i>vec<sub>1</sub> vec<sub>2</sub>
           ...</i>)
        </code>
        <br />
        <br />
        Example:
        <br />
        <br />
        <code class="example-call">
          (vector-skip number? '#(1 2 a b 3 4 c d))
        </code>
        <br />
        <code class="example-value">
          2
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-skip-right">
          (vector-skip-right <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                                ...</i>)
          -&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-skip">vector-skip</a></tt>, but it
        searches for a non-matching element right-to-left, rather than
        left-to-right, and it is an error if all of the vectors do not
        have the same length.  This is equivalent to:
        <br />
        <br />
        <code class="indented">
          (<a href="#vector-index">vector-index-right</a>
           (&lambda; (x<sub><i>1</i></sub> x<sub><i>2</i></sub>
                      <i> ...</i>)
             (not (<i>pred?</i> x<sub><i>1</i></sub>
                                x<sub><i>1</i></sub>
                                <i> ...</i>)))
           <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           &nbsp;&nbsp;&nbsp;&nbsp;
           <i>vec<sub>1</sub> vec<sub>2</sub>
           ...</i>)
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-binary-search">
          (vector-binary-search <i>vec value cmp</i>)
          -&gt; exact nonnegative integer or #f
        </a>
      </dt>
      <dd>
        <p>Similar to <tt><a href="#vector-index">vector-index</a></tt>
        and
        <tt><a href="#vector-index-right">vector-index-right</a></tt>,
        but instead of searching left to right or right to left, this
        performs a binary search.
        If there is more than one element of <i>vec</i> that matches
        <i>value</i> in the sense of <i>cmp</i>,
        <code>vector-binary-search</code> may return the index of any of them.</p>
        <p><tt><i>cmp</i></tt> should be a
        procedure of two arguments and return a negative integer, which
        indicates that its first argument is less than its second,
        zero, which indicates that they are equal, or a positive
        integer, which indicates that the first argument is greater
        than the second argument.  An example <tt><i>cmp</i></tt> might
        be:
        <br />
        <br />
        <code class="indented">
          (&lambda; (<i>char<sub>1</sub></i> <i>char<sub>2</sub></i>)
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;(cond ((char&lt;? <i>char<sub>1</sub>
                                           char<sub>2</sub></i>)
                             -1)
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          ((char=? <i>char<sub>1</sub>
                      char<sub>2</sub></i>)
           0)
        </code>
        <br />
        <code class="indented">
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (else 1)))
        </code>
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-any">
          (vector-any <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                         ...</i>)
          -&gt; value or #f
        </a>
      </dt>
      <dd>
        Finds the first set of elements in parallel from
        <tt><i>vec<sub>1</sub> vec<sub>2</sub>
        ...</i></tt> for which
        <tt><i>pred?</i></tt> returns a true value.  If such a parallel
        set of elements exists, <tt>vector-any</tt> returns the value
        that <tt><i>pred?</i></tt> returned for that set of elements.
        The iteration is strictly left-to-right.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-every">
          (vector-every <i>pred? vec<sub>1</sub> vec<sub>2</sub>
                           ...</i>)
          -&gt; value or #f
        </a>
      </dt>
      <dd>
        If, for every index <tt><i>i</i></tt> between 0 and the length
        of the shortest vector argument, the set of elements
        <tt>(<a href="#vector-ref">vector-ref</a> <i>vec<sub>1</sub></i>
                                                 <i>i</i>)
            (<a href="#vector-ref">vector-ref</a> <i>vec<sub>2</sub></i>
                                                 <i>i</i>)
            ...</tt>
        satisfies <tt><i>pred?</i></tt>, <tt>vector-every</tt> returns
        the value that <tt><i>pred?</i></tt> returned for the last
        set of elements, at the last index of the shortest vector.  The
        iteration is strictly left-to-right.
        <br />
        <br />
      </dd>
      <dt class="proc-spec">
        <a name="vector-partition">
          (vector-partition <i>pred? vec</i>)
          -&gt; vector and integer
        </a>
      </dt>
      <dd>
        A vector the same size as <tt><i>vec</i></tt> is newly allocated
        and filled with all the elements of <tt><i>vec</i></tt> that
        satisfy <tt><i>pred?</i></tt> in their original order followed
        by all the elements that do not satisfy <tt><i>pred?</i></tt>,
        also in their original order.

        <br />
        <br />
        Two values are returned, the newly allocated vector and the index
        of the leftmost element that does not satisfy <tt><i>pred?</i></tt>.
        <br />
        <br />
      </dd>
    </dl>

    <h2><a name="Mutators">5.7. Mutators</a></h2>
    <dl>
      <dt class="proc-spec">
        <a name="vector-set-bang">
          (vector-set! <i>vec i value</i>)
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Assigns the contents of the location at <tt><i>i</i></tt> in
        <tt><i>vec</i></tt> to <tt><i>value</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-swap-bang">
          (vector-swap! <i>vec i j</i>)
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        Swaps or exchanges the values of the locations in
        <tt><i>vec</i></tt> at <tt><i>i</i></tt> &amp;
        <tt><i>j</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-fill-bang">
          (vector-fill! <i>vec fill</i> [<i>start</i> [<i>end</i>]])
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Assigns the value of every location in <tt><i>vec</i></tt>
        between <tt><i>start</i></tt>, which defaults to <tt>0</tt> and
        <tt><i>end</i></tt>, which defaults to the length of
        <tt><i>vec</i></tt>, to <tt><i>fill</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-reverse-bang">
          (vector-reverse! <i>vec</i> [<i>start</i> [<i>end</i>]])
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        Destructively reverses the contents of the sequence of
        locations in <tt><i>vec</i></tt> between <tt><i>start</i></tt>
        and <tt><i>end</i></tt>.  <tt><i>Start</i></tt> defaults to
        <tt>0</tt> and <tt><i>end</i></tt> defaults to the length of
        <tt><i>vec</i></tt>.  Note that this does not deeply reverse.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-copy-bang">
          (vector-copy! <i>to at from</i>
                        [<i>start</i> [<i>end</i>]])
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>]
        Copies the elements of vector <tt><i>from</i></tt>
        between <tt><i>start</i></tt> and <tt><i>end</i></tt>
        to vector <tt><i>to</i></tt>, starting at <tt><i>at</i></tt>.
        The order in which elements
        are copied is unspecified, except that if the source and destination
        overlap, copying takes place as if the source is first
        copied into a temporary vector and then into the destination.
        This can be achieved without allocating storage by
        making sure to copy in the correct direction in such circumstances.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-reverse-copy-bang">
          (vector-reverse-copy! <i>to at from</i>
                                [<i>start</i> [<i>end</i>]])
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-copy-bang">vector-copy!</a></tt>, but
        the elements appear in <tt><i>to</i></tt> in reverse order.
        <br />
        <br />
      </dd>
      <dt class="proc-spec">
        <a name="vector-unfold-bang">
          (vector-unfold! <i>f vec start end initial-seed ...</i>)
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-unfold">vector-unfold</a></tt>, but
        the elements are copied into the vector <i>vec</i> starting
        at element <i>start</i> rather than into a newly allocated vector.
        Terminates when <i>end-start</i> elements have been generated.
        <br />
        <br />
      </dd>
      <dt class="proc-spec">
        <a name="vector-unfold-right-bang">
          (vector-unfold-right! <i>f vec start end initial-seed ...</i>)
          -&gt; unspecified
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-unfold-bang">vector-unfold!</a></tt>, but the
        elements are copied in reverse order into the vector <i>vec</i>
        starting at the index preceding <i>end</i>.
        <br />
        <br />
      </dd>
    </dl>
    <h2><a name="Conversion">5.8. Conversion</a></h2>
    <dl>

      <dt class="proc-spec">
        <a name="vector-to-list">
          (vector-&gt;list <i>vec</i>
                                   [<i>start</i> [<i>end</i>]])
          -&gt; proper-list
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>]
        Creates a list containing the elements in <tt><i>vec</i></tt>
        between <tt><i>start</i></tt>, which defaults to <tt>0</tt>,
        and <tt><i>end</i></tt>, which defaults to the length of
        <tt><i>vec</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="reverse-vector-to-list">
          (reverse-vector-&gt;list <i>vec</i>
                                   [<i>start</i> [<i>end</i>]])
          -&gt; proper-list
        </a>
      </dt>
      <dd>
        Like <tt><a href="#vector-to-list">vector-&gt;list</a></tt>,
        but the resulting list contains the elements in reverse of
        <tt><i>vec</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="list-to-vector">
          (list-&gt;vector <i>proper-list</i>) -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Creates a vector of elements from <tt><i>proper-list</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="reverse-list-to-vector">
          (reverse-list-&gt;vector <i>proper-list</i>) -&gt; vector
        </a>
      </dt>
      <dd>
        Like <tt><a href="#list-to-vector">list-&gt;vector</a></tt>,
        but the resulting vector contains the elements in reverse of
        <tt><i>proper-list</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="string-to-vector">
          (string-&gt;vector <i>string</i> [<i>start</i> [<i>end</i>]])
          -&gt; vector
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Creates a vector containing the elements in <tt><i>string</i></tt>
        between <tt><i>start</i></tt>, which defaults to <tt>0</tt>,
        and <tt><i>end</i></tt>, which defaults to the length of
        <tt><i>string</i></tt>.
        <br />
        <br />
      </dd>

      <dt class="proc-spec">
        <a name="vector-to-string">
          (vector-&gt;string <i>vec</i> [<i>start</i> [<i>end</i>]])
          -&gt; string
        </a>
      </dt>
      <dd>
        [<a href="#R7RS-small"><i>R7RS-small</i></a>] Creates a string containing the elements in <tt><i>vec</i></tt>
        between <tt><i>start</i></tt>, which defaults to <tt>0</tt>,
        and <tt><i>end</i></tt>, which defaults to the length of
        <tt><i>vec</i></tt>.  It is an error if the elements are not characters.
        <br />
        <br />
      </dd>

    </dl>

    <h1 class="nonheader">
      <a name="SampImpl">6. Sample Implementation</a>
    </h1>
    <p>
      The sample implementation is in the repository of this SRFI.
      It has only one non-R5RS dependency:
      <a href="#SRFI-23">SRFI 23</a>'s <tt>error</tt> procedure,
      which is also provided by R7RS-small.
      It is in the public domain, or alternatively under the same copyright
      as this SRFI.  The following files are provided:
    </p>
    <ul><li><code>vectors-impl.scm</code> -
    a modified version of the implementation of SRFI 43</li>
    <li><code>vectors.scm</code> -
    a Chicken library showing what to export for an R5RS implementation</li>
    <li><code>vectors.sld</code> -
    an R7RS library that excludes what R7RS-small already provides</li>
    <li><code>vectors-test.scm</code> -
    tests using the Chicken test egg (also available on Chibi)</li>
    </ul>

    <h1 class="nonheader">
      <a name="Acknowledgements">7. Acknowledgements</a>
    </h1>
    <p>These acknowledgements are copied from SRFI 43.</p>
    <p>
      Thanks to Olin Shivers for his wonderfully complete
      <a href="#SRFI-1">list</a> and <a href="#SRFI-13">string</a>
      packages; to all the members of the
      <a href="http://scheme-irc.webhop.org/"><tt>#scheme</tt> IRC
      channel</a> on <a href="http://www.freenode.net/">Freenode</a>
      who nitpicked a great deal, but also helped quite a lot in
      general, and helped test the reference implementation in various
      Scheme systems; to Michael Burschik for his numerous comments; to
      Sergei Egorov for helping to narrow down the procedures; to Mike
      Sperber for putting up with an <i>extremely</i> overdue draft; to
      Felix Winkelmann for continually bugging me about finishing up the
      SRFI so that it would be only overdue and not withdrawn; and to
      everyone else who gave questions, comments, thoughts, or merely
      attention to the SRFI.
    </p>

    <h1 class="nonheader"><a name="References">8. References</a></h1>
    <dl>
      <dt class="ref"><a name="R5RS">R5RS</a></dt>
      <dd>
        <i>R5RS: The Revised<sup>5</sup> Report on Scheme</i>
        <br />
        R. Kelsey, W. Clinger, J. Rees (editors).
        <br />
        Higher-Order and Symbolic Computation, Vol. 11, No. 1,
        September, 1998
        <br />
        and
        <br />
        ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998
        <br />
        Available at:
        <a href="http://www.schemers.org/Documents/Standards/R5RS/">
          http://www.schemers.org/Documents/Standards/R5RS/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="R7RS-small">R7RS-small</a></dt>
      <dd>
        <i>R7RS: The Revised<sup>7</sup> Report on Scheme</i>
        <br />
        A. Shinn et al. (editors).
        <br />
        Available at:
        <a href="http://r7rs.org">
          http://r7rs.org
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI">SRFI</a></dt>
      <dd>
        <i>SRFI: Scheme Request for Implementation</i>
        <br />
        The SRFI website can be found at:
        <a href="https://srfi.schemers.org/">
          https://srfi.schemers.org/
        </a>
        <br />
        The SRFIs mentioned in this document are described later.
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-1">SRFI 1</a></dt>
      <dd>
        <i>SRFI 1: List Library</i>
        <br />
        A SRFI of list processing procedures, written by Olin Shivers.
        <br />
        Available at:
        <a href="https://srfi.schemers.org/srfi-1/">
          https://srfi.schemers.org/srfi-1/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-13">SRFI 13</a></dt>
      <dd>
        <i>SRFI 13: String Library</i>
        <br />
        A SRFI of string processing procedures, written by Olin
        Shivers.
        <br />
        Available at:
        <a href="https://srfi.schemers.org/srfi-13/">
          https://srfi.schemers.org/srfi-13/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-23">SRFI 23</a></dt>
      <dd>
        <i>SRFI 23: Error Reporting Mechanism</i>
        <br />
        A SRFI that defines a new primitive (<tt>error</tt>) for
        reporting that an error occurred, written by Stephan Houben.
        <br />
        Available at:
        <a href="https://srfi.schemers.org/srfi-23/">
          https://srfi.schemers.org/srfi-23/
        </a>
        <br />
        <br />
      </dd>

      <dt class="ref"><a name="SRFI-43">SRFI 43</a></dt>
      <dd>
        <i>SRFI 43: Vector Library (draft)</i>
        <br />
        The direct predecessor of this SRFI, written by Taylor Campbell.
        <br />
        Available at:
        <a href="https://srfi.schemers.org/srfi-43/">
          https://srfi.schemers.org/srfi-43/
        </a>
      </dd>
    </dl>

    <h1 class="nonheader"><a name="Copyright">9. Copyright</a></h1>
    <p>
     Copyright (C) Taylor Campbell (2003).  All rights reserved.
    </p>
    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the "Software"), to deal in the Software without
      restriction, including without limitation the rights to use,
      copy, modify, merge, publish, distribute, sublicense, and/or
      sell copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following
      conditions:
    </p>
    <p>
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
    </p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.
    </p>
    <hr />
    <address>Editor: <a href="mailto:srfi minus editors at srfi dot schemers dot org">Arthur A. Gleckler</a></address>
  </body>
</html>
